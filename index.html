<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zero Distance v8</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            color: #fff;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- CRT Effect --- */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
        
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 11;
        }

        /* --- UI Layer --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-header {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            text-shadow: 2px 2px 0 #000;
        }
        
        .score-box { text-align: left; }
        .score-label { font-size: 10px; color: #aaa; margin-bottom: 5px; display: block; }
        #score-display { font-size: 20px; color: #fff; }

        .status-box { text-align: right; }
        .status-label { font-size: 10px; color: #aaa; margin-bottom: 5px; }
        #shield-display { color: #0ff; font-size: 12px; display: none; }

        /* Boss HP Bar */
        #boss-hud {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            display: none;
            text-align: center;
        }
        .boss-name { font-size: 12px; color: #f00; margin-bottom: 5px; text-shadow: 1px 1px 0 #000; }
        .hp-bar-frame {
            width: 100%;
            height: 10px;
            background: #300;
            border: 2px solid #fff;
        }
        #hp-bar-fill {
            width: 100%;
            height: 100%;
            background: #f00;
            transition: width 0.1s;
        }

        /* Warning Overlay */
        #warning-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 40px;
            text-align: center;
            display: none;
            text-shadow: 4px 4px 0 #000;
            width: 100%;
            background: rgba(0,0,0,0.5);
            padding: 20px 0;
        }
        .warning-blink { animation: warnBlink 0.1s infinite; } /* 点滅速度アップ */
        @keyframes warnBlink { 0% {opacity:1;} 50% {opacity:0;} 100% {opacity:1;} }

        /* Mobile Shot Button */
        #mobile-shot-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            touch-action: none;
            z-index: 100;
        }
        #mobile-shot-btn:active {
            background: rgba(255, 0, 0, 0.6);
            transform: scale(0.95);
        }

        /* Start / Game Over */
        #overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            min-width: 300px;
            z-index: 200;
        }

        h1 { font-size: 32px; margin: 0 0 20px 0; color: #fff; text-shadow: 4px 4px 0 #333; line-height: 1.2; }
        .subtitle { font-size: 12px; color: #f0f; margin-bottom: 30px; letter-spacing: 2px; text-transform: uppercase; }
        .instruction { font-size: 10px; color: #aaa; margin: 10px 0; line-height: 1.6; }
        .blink { animation: blinker 1s steps(2, start) infinite; color: #ffff00; font-size: 14px; margin-top: 30px; }
        @keyframes blinker { 50% { opacity: 0; } }
        
        .controls-guide {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 0 40px;
            box-sizing: border-box;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="ui-layer">
        <div class="hud-header">
            <div class="score-box">
                <span class="score-label">SCORE</span>
                <span id="score-display">000000</span>
            </div>
            <div class="status-box">
                <div id="shield-display">[SHIELD ACTIVE]</div>
            </div>
        </div>

        <div id="warning-overlay">
            <div class="warning-blink">WARNING</div>
            <div style="font-size:16px; margin-top:10px; color:#fff;">HUGE ENERGY DETECTED</div>
        </div>

        <div id="boss-hud">
            <div class="boss-name">THE CORE</div>
            <div class="hp-bar-frame"><div id="hp-bar-fill"></div></div>
        </div>

        <div id="mobile-shot-btn">SHOT</div>

        <div id="overlay-screen">
            <h1>ZERO<br>DISTANCE</h1>
            <div class="subtitle">Risk It All</div>
            <div id="screen-content">
                <div class="blink">[ LOADING... ]</div>
            </div>
            <div class="instruction" style="margin-top: 30px; font-size: 8px; color: #666;">
                <span style="color:#0ff">AUTO AIM ENABLED</span><br><br>
                PC: [SPACE] or [CLICK] to SHOOT<br>MOBILE: [SHOT BUTTON] to SHOOT
            </div>
        </div>

        <div class="controls-guide" id="mobile-guide" style="display:none;">
            <div style="margin-right: auto; margin-left: 20px;">DRAG TO MOVE</div>
        </div>
    </div>
</div>

<script>
/**
 * ------------------------------------------------------------------
 * SPRITES
 * ------------------------------------------------------------------
 */
const Sprites = {
    player: [
        [0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,0,1,1,0,1,0,1,1,0,0],
        [0,1,1,1,0,1,0,1,1,1,0],
        [0,1,1,0,0,1,0,0,1,1,0],
        [1,1,0,0,0,0,0,0,0,1,1],
        [1,0,0,0,0,0,0,0,0,0,1]
    ],
    enemy: [
        [0,0,0,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,1,1,0],
        [1,1,0,1,1,1,1,1,0,1,1],
        [1,1,0,1,1,1,1,1,0,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [0,1,1,0,1,1,1,0,1,1,0],
        [0,1,1,1,0,0,0,1,1,1,0],
        [0,0,1,1,1,0,1,1,1,0,0],
        [0,0,1,0,1,0,1,0,1,0,0],
        [0,0,1,0,0,0,0,0,1,0,0]
    ],
    boss: [
        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
        [0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0],
        [0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0],
        [0,1,1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,0],
        [1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0],
        [1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0],
        [1,1,1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0],
        [1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0],
        [0,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0],
        [0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0],
        [0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    // 7x7 Items
    item_p: [
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,0,0,1,0,0,1],
        [1,0,0,1,0,0,1],
        [1,0,0,1,0,0,1],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0]
    ],
    item_s: [
        [0,0,1,1,1,0,0],
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,1,0,1,0,1,1],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0],
        [0,0,1,1,1,0,0]
    ],
    // New: Rapid (R)
    item_r: [
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,0,0,1,1,1,0],
        [1,0,0,1,1,0,0],
        [1,0,0,1,0,1,0],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0]
    ],
    // New: Bomb (B)
    item_b: [
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,0,0,1,1,0,1],
        [1,0,0,1,0,1,1],
        [1,0,0,1,1,0,1],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0]
    ]
};

function drawPixelArt(ctx, pattern, pixelSize, color) {
    const rows = pattern.length;
    const cols = pattern[0].length;
    const offsetX = -(cols * pixelSize) / 2;
    const offsetY = -(rows * pixelSize) / 2;

    ctx.fillStyle = color;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (pattern[r][c] === 1) {
                ctx.fillRect(offsetX + c * pixelSize, offsetY + r * pixelSize, pixelSize, pixelSize);
            }
        }
    }
}

/**
 * ------------------------------------------------------------------
 * AUDIO SYSTEM
 * ------------------------------------------------------------------
 */
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    resume: function() {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot: function() {
        this.playTone(800, 'square', 0.05, 0.05);
        this.playTone(300, 'sawtooth', 0.05, 0.05);
    },
    playRicochet: function() {
        this.playTone(1200, 'triangle', 0.1, 0.05);
    },
    playHit: function() {
        this.playTone(150, 'square', 0.1, 0.1);
    },
    playPowerup: function() {
        this.playTone(600, 'sine', 0.1, 0.1);
        setTimeout(() => this.playTone(1200, 'square', 0.2, 0.1), 100);
    },
    playBomb: function() {
        if (!this.ctx) return;
        this.playTone(100, 'sawtooth', 0.5, 0.5);
        setTimeout(() => this.playTone(50, 'square', 0.5, 0.5), 100);
    },
    playWarning: function() {
        this.playTone(150, 'sawtooth', 0.2, 0.3); // 短く
        setTimeout(() => this.playTone(100, 'sawtooth', 0.2, 0.3), 100);
    },
    playExplosion: function() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.4;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
        this.playTone(50, 'sawtooth', 0.3, 0.3);
    }
};

/**
 * ------------------------------------------------------------------
 * GAME VARIABLES & HIGH SCORE SYSTEM
 * ------------------------------------------------------------------
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score-display');
const shieldEl = document.getElementById('shield-display');
const overlayScreen = document.getElementById('overlay-screen');
const screenContent = document.getElementById('screen-content');
const warningOverlay = document.getElementById('warning-overlay');
const bossHud = document.getElementById('boss-hud');
const hpBarFill = document.getElementById('hp-bar-fill');
const mobileGuide = document.getElementById('mobile-guide');
const mobileShotBtn = document.getElementById('mobile-shot-btn');

let width, height;
const isMobile = 'ontouchstart' in window;
if (isMobile) {
    mobileGuide.style.display = 'flex';
    mobileShotBtn.style.display = 'flex';
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    ctx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', resize);
resize();

const STATE = { TITLE: 0, PLAYING: 1, BOSS_WARNING: 2, GAMEOVER: 3 };
let currentState = STATE.TITLE;
let score = 0;
let highScore = 0;
let frameCount = 0;
let shakeIntensity = 0;
let freezeTimer = 0;
let nextBossScore = 3000;
let bossActive = false;

// High Score
try {
    const saved = localStorage.getItem('ZeroDistance_HighScore');
    if (saved) highScore = parseInt(saved, 10);
} catch(e) { console.log("LS Error"); }

function showTitleScreen() {
    currentState = STATE.TITLE;
    screenContent.innerHTML = `
        <p class="instruction" style="color:#f88;">KILL AT ZERO RANGE.</p>
        <p class="instruction">GET ITEMS FROM CLOSE KILLS.</p>
        <p style="margin-top:20px; color:#ffff00; font-size:12px;">HI-SCORE: ${highScore}</p>
        <div class="blink" style="margin-top:30px;">[ TAP TO START ]</div>
    `;
    overlayScreen.classList.remove('hidden');
    bossHud.style.display = 'none';
    warningOverlay.style.display = 'none';
    mobileShotBtn.style.display = 'none';
}

showTitleScreen();

const Input = {
    keys: {},
    mouse: { x: 0, y: 0, down: false },
    shot: { down: false },
    touch: {
        id: null, 
        start: {x:0, y:0},
        curr: {x:0, y:0},
        active: false
    }
};

window.addEventListener('keydown', e => {
    Input.keys[e.key] = true;
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') Input.shot.down = true;
});
window.addEventListener('keyup', e => {
    Input.keys[e.key] = false;
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') Input.shot.down = false;
});
window.addEventListener('mousemove', e => { Input.mouse.x = e.clientX; Input.mouse.y = e.clientY; });
window.addEventListener('mousedown', () => Input.shot.down = true);
window.addEventListener('mouseup', () => Input.shot.down = false);

mobileShotBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    Input.shot.down = true;
    mobileShotBtn.style.background = 'rgba(255, 0, 0, 0.6)';
}, { passive: false });

mobileShotBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    Input.shot.down = false;
    mobileShotBtn.style.background = 'rgba(255, 0, 0, 0.3)';
}, { passive: false });

window.addEventListener('touchstart', e => {
    if (e.target.closest('#mobile-shot-btn') || e.target.closest('#overlay-screen')) return; 
    e.preventDefault();
    if (!Input.touch.active && e.changedTouches.length > 0) {
        const t = e.changedTouches[0];
        Input.touch.id = t.identifier;
        Input.touch.start = { x: t.clientX, y: t.clientY };
        Input.touch.curr = { x: t.clientX, y: t.clientY };
        Input.touch.active = true;
    }
}, { passive: false });

window.addEventListener('touchmove', e => {
    e.preventDefault();
    if (Input.touch.active) {
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === Input.touch.id) {
                Input.touch.curr = { x: e.changedTouches[i].clientX, y: e.changedTouches[i].clientY };
                break;
            }
        }
    }
}, { passive: false });

window.addEventListener('touchend', e => {
    e.preventDefault();
    if (Input.touch.active) {
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === Input.touch.id) {
                Input.touch.active = false;
                Input.touch.id = null;
                break;
            }
        }
    }
}, { passive: false });

const handleStartInteraction = (e) => {
    if (e.target.closest('#mobile-shot-btn')) return;
    e.stopPropagation();
    if(e.cancelable && e.type === 'touchstart') e.preventDefault();

    if (currentState !== STATE.PLAYING && currentState !== STATE.BOSS_WARNING) {
        startGame();
    }
};

overlayScreen.addEventListener('mousedown', handleStartInteraction);
overlayScreen.addEventListener('touchstart', handleStartInteraction, { passive: false });

function startGame() {
    AudioSys.init();
    AudioSys.resume();
    
    player = new Player();
    enemies = [];
    bullets = [];
    enemyBullets = []; // ★リトライ時に敵弾を全消去
    particles = [];
    popups = [];
    items = [];
    score = 0;
    shakeIntensity = 0;
    freezeTimer = 0;
    frameCount = 0;
    nextBossScore = 3000;
    bossActive = false;
    
    updateScoreDisplay();
    overlayScreen.classList.add('hidden');
    bossHud.style.display = 'none';
    warningOverlay.style.display = 'none';
    if (isMobile) mobileShotBtn.style.display = 'flex';
    currentState = STATE.PLAYING;
    loop();
}

function updateScoreDisplay() {
    scoreEl.innerText = score.toString().padStart(6, '0');
    shieldEl.style.display = player && player.shield ? 'block' : 'none';
}

function spawnBoss() {
    currentState = STATE.BOSS_WARNING;
    warningOverlay.style.display = 'block';
    let count = 0;
    // 演出を短縮 (300ms * 4回 = 1.2秒)
    const interval = setInterval(() => {
        AudioSys.playWarning();
        count++;
        if (count > 3) {
            clearInterval(interval);
            setTimeout(() => {
                warningOverlay.style.display = 'none';
                currentState = STATE.PLAYING;
                bossActive = true;
                enemies.push(new Boss());
                bossHud.style.display = 'block';
            }, 500); // 待機も短縮
        }
    }, 300);
}

/**
 * ------------------------------------------------------------------
 * CLASSES
 * ------------------------------------------------------------------
 */
class Player {
    constructor() {
        this.x = width / 2;
        this.y = height / 2;
        this.pixelSize = 3; 
        this.size = 11 * this.pixelSize;
        this.speed = 4;
        this.angle = 0; 
        this.color = '#00ffff'; 
        this.shootCooldown = 0;
        this.powerUpTimer = 0; // Wide Shot
        this.rapidTimer = 0;   // Rapid Fire (New)
        this.shield = false;
    }

    update() {
        let dx = 0;
        let dy = 0;
        if (Input.keys['w'] || Input.keys['ArrowUp']) dy -= 1;
        if (Input.keys['s'] || Input.keys['ArrowDown']) dy += 1;
        if (Input.keys['a'] || Input.keys['ArrowLeft']) dx -= 1;
        if (Input.keys['d'] || Input.keys['ArrowRight']) dx += 1;

        if (Input.touch.active) {
            const tx = Input.touch.curr.x - Input.touch.start.x;
            const ty = Input.touch.curr.y - Input.touch.start.y;
            const dist = Math.hypot(tx, ty);
            const deadZone = 10;
            if (dist > deadZone) {
                dx = tx / dist;
                dy = ty / dist;
                const speedFactor = Math.min(dist / 50, 1.0);
                dx *= speedFactor;
                dy *= speedFactor;
            }
        }

        if (!Input.touch.active && (dx !== 0 || dy !== 0)) {
            const length = Math.hypot(dx, dy);
            if (length > 1) { 
                dx /= length;
                dy /= length;
            }
        }

        this.x += dx * this.speed;
        this.y += dy * this.speed;
        this.x = Math.max(this.size, Math.min(width - this.size, this.x));
        this.y = Math.max(this.size, Math.min(height - this.size, this.y));

        if (this.shootCooldown > 0) this.shootCooldown--;
        if (this.powerUpTimer > 0) this.powerUpTimer--;
        if (this.rapidTimer > 0) this.rapidTimer--;
        
        // Auto Aim
        let nearestEnemy = null;
        let minDist = Infinity;
        const rangeLimit = Math.max(width, height) * 0.9; 

        enemies.forEach(e => {
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < minDist && d < rangeLimit) {
                minDist = d;
                nearestEnemy = e;
            }
        });

        if (nearestEnemy) {
            this.angle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
        } else if (dx !== 0 || dy !== 0) {
            this.angle = Math.atan2(dy, dx);
        }

        // Manual Fire with Rapid Check
        if (Input.shot.down && this.shootCooldown <= 0) {
            this.shoot();
            // ラピッドアイテム所持時はクールダウン半減
            this.shootCooldown = this.rapidTimer > 0 ? 4 : 8;
        }
    }

    shoot() {
        const spread = (Math.random() - 0.5) * 0.1;
        if (this.powerUpTimer > 0) {
            bullets.push(new Bullet(this.x, this.y, this.angle + spread));
            bullets.push(new Bullet(this.x, this.y, this.angle + spread + 0.3));
            bullets.push(new Bullet(this.x, this.y, this.angle + spread - 0.3));
        } else {
            bullets.push(new Bullet(this.x, this.y, this.angle + spread));
        }
        AudioSys.playShoot();
        this.x -= Math.cos(this.angle) * 2;
        this.y -= Math.sin(this.angle) * 2;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2);
        
        let color = this.color;
        if (this.shield) color = '#ffffff';
        else if (this.rapidTimer > 0 && frameCount % 4 < 2) color = '#ff8800'; // Rapid時は点滅
        
        drawPixelArt(ctx, Sprites.player, this.pixelSize, color);
        
        if (this.shield) {
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(100, 255, 255, ${0.5 + Math.sin(frameCount*0.2)*0.3})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        ctx.restore();
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, 90, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

class Enemy {
    constructor() {
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { this.x = Math.random() * width; this.y = -50; }
        else if (edge === 1) { this.x = width + 50; this.y = Math.random() * height; }
        else if (edge === 2) { this.x = Math.random() * width; this.y = height + 50; }
        else { this.x = -50; this.y = Math.random() * height; }

        this.pixelSize = 3 + Math.random();
        this.size = 13 * this.pixelSize;
        this.speed = 1.0 + Math.random() * 2.0;
        this.angle = 0;
        this.hp = 3;
        this.color = '#ff0044';
        this.vx = 0; 
        this.vy = 0;
        this.isBoss = false;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.9;
        this.vy *= 0.9;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        this.angle = Math.atan2(dy, dx);
        
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2);
        const drawColor = (this.hp < 3 && frameCount % 4 < 2) ? '#ffffff' : this.color;
        drawPixelArt(ctx, Sprites.enemy, this.pixelSize, drawColor);
        ctx.restore();
    }
}

class Boss extends Enemy {
    constructor() {
        super();
        this.x = width / 2;
        this.y = -100;
        this.pixelSize = 6; 
        this.size = 25 * this.pixelSize;
        this.hp = 300;
        this.maxHp = 300;
        this.speed = 1.0;
        this.color = '#aa00ff';
        this.isBoss = true;
        this.shootTimer = 0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.9;
        this.vy *= 0.9;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        this.angle = Math.atan2(dy, dx);

        if (dist > 200) {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
        } else {
             this.x -= Math.cos(this.angle) * (this.speed * 0.5);
             this.y -= Math.sin(this.angle) * (this.speed * 0.5);
        }

        this.shootTimer++;
        if (this.shootTimer > 40) {
            this.shoot();
            this.shootTimer = 0;
        }

        this.x = Math.max(this.size, Math.min(width - this.size, this.x));
        this.y = Math.max(this.size, Math.min(height - this.size, this.y));
    }

    shoot() {
        const count = 12;
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 / count) * i + (frameCount * 0.1);
            enemyBullets.push(new EnemyBullet(this.x, this.y, angle));
        }
        AudioSys.playShoot();
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2);
        const blink = (this.hp < 100 && frameCount % 6 < 3);
        const drawColor = blink ? '#ff0000' : this.color;
        drawPixelArt(ctx, Sprites.boss, this.pixelSize, drawColor);
        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 14;
        this.life = 50;
        this.dead = false;
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        if (this.life <= 0) this.dead = true;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(-8, -1.5, 16, 3);
        ctx.restore();
    }
}

class EnemyBullet {
    constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 4;
        this.life = 200;
        this.dead = false;
        this.size = 8;
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.dead = true;
    }
    draw(ctx) {
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
        ctx.fill();
    }
}

class Item {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'p', 's', 'r', 'b'
        this.life = 600; 
        this.pixelSize = 3;
        this.size = 20;
    }
    update() {
        this.life--;
        this.y += Math.sin(frameCount * 0.1) * 0.5;
    }
    draw(ctx) {
        if (this.life < 100 && this.life % 10 < 5) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        let sprite, color;
        // アイテム描画分岐
        switch(this.type) {
            case 'p': sprite = Sprites.item_p; color = '#ffaa00'; break;
            case 's': sprite = Sprites.item_s; color = '#00aaff'; break;
            case 'r': sprite = Sprites.item_r; color = '#ff4400'; break;
            case 'b': sprite = Sprites.item_b; color = '#aa00ff'; break;
        }
        drawPixelArt(ctx, sprite, this.pixelSize, color);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = life;
        this.maxLife = life;
        this.size = Math.random() * 6 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.vx *= 0.92;
        this.vy *= 0.92;
        this.size *= 0.95;
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
    }
}

class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 50;
        this.size = size;
        this.vy = -0.5;
    }
    update() {
        this.y += this.vy;
        this.life--;
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.min(1, this.life / 10);
        ctx.fillStyle = this.color;
        ctx.font = `${this.size}px "Press Start 2P"`; 
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

let player;
let enemies = [];
let bullets = [];
let enemyBullets = [];
let items = [];
let particles = [];
let popups = [];

function update() {
    if (freezeTimer > 0) {
        freezeTimer--;
        return;
    }

    if (!bossActive && score >= nextBossScore) {
        spawnBoss();
        nextBossScore += 5000;
        return; 
    }

    if (!bossActive) {
        if (frameCount % Math.max(20, 60 - Math.floor(frameCount / 500)) === 0) {
            enemies.push(new Enemy());
        }
    }

    player.update();

    bullets.forEach(b => b.update());
    bullets = bullets.filter(b => !b.dead);
    
    enemyBullets.forEach(b => b.update());
    enemyBullets = enemyBullets.filter(b => !b.dead);

    items.forEach(i => i.update());
    items = items.filter(i => i.life > 0);
    
    // アイテム取得処理
    items.forEach(item => {
        const dist = Math.hypot(player.x - item.x, player.y - item.y);
        if (dist < player.size + item.size) {
            item.life = 0;
            AudioSys.playPowerup();
            
            if (item.type === 'p') {
                player.powerUpTimer = 600; 
                popups.push(new FloatingText(player.x, player.y - 30, "WIDE SHOT!", "#fa0", 12));
            } else if (item.type === 's') {
                player.shield = true;
                popups.push(new FloatingText(player.x, player.y - 30, "SHIELD!", "#0af", 12));
            } else if (item.type === 'r') {
                player.rapidTimer = 600; // 10秒間連射
                popups.push(new FloatingText(player.x, player.y - 30, "RAPID!", "#f40", 12));
            } else if (item.type === 'b') {
                // Bomb Effect
                AudioSys.playBomb();
                shakeIntensity = 20;
                enemyBullets = []; // 敵弾全消去
                // 全敵ダメージ
                enemies.forEach(e => {
                    e.hp -= 5;
                    // ノックバック
                    const angle = Math.atan2(e.y - player.y, e.x - player.x);
                    e.vx = Math.cos(angle) * 20;
                    e.vy = Math.sin(angle) * 20;
                    // エフェクト
                    for(let i=0; i<5; i++) particles.push(new Particle(e.x, e.y, '#fff', 5, 20));
                });
                popups.push(new FloatingText(player.x, player.y - 40, "EMP BLAST!", "#d0f", 16));
                
                // 画面全体フラッシュ的なパーティクル
                for(let i=0; i<20; i++) {
                    particles.push(new Particle(Math.random()*width, Math.random()*height, '#a0f', 10, 30));
                }
            }
        }
    });

    enemies.forEach((e) => {
        e.update();
        
        const distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
        if (distToPlayer < (player.size/3 + e.size/3)) {
            if (player.shield) {
                player.shield = false; 
                popups.push(new FloatingText(player.x, player.y, "BLOCK!", "#0ff", 15));
                AudioSys.playRicochet();
                const angle = Math.atan2(e.y - player.y, e.x - player.x);
                e.vx = Math.cos(angle) * 15;
                e.vy = Math.sin(angle) * 15;
                e.hp -= 1;
                enemyBullets = [];
                shakeIntensity = 5;
            } else {
                gameOver();
            }
        }

        bullets.forEach(b => {
            if (b.dead) return;
            const distToBullet = Math.hypot(e.x - b.x, e.y - b.y);
            const hitRadius = e.isBoss ? e.size/2 : e.size/2 + 5;
            
            if (distToBullet < hitRadius) {
                b.dead = true;
                const impactDist = Math.hypot(player.x - e.x, player.y - e.y);
                
                const ZERO_DIST = 90;
                const MID_DIST = 250;
                
                if (impactDist < ZERO_DIST) {
                    let damage = 5;
                    if (!e.isBoss) damage = 100;
                    
                    e.hp -= damage;
                    
                    if (e.isBoss) {
                        shakeIntensity = 3; 
                        AudioSys.playHit();
                    }

                    if (e.hp <= 0) {
                        freezeTimer = e.isBoss ? 20 : 5; 
                        shakeIntensity = e.isBoss ? 30 : 15;
                        AudioSys.playExplosion();
                        score += e.isBoss ? 5000 : 1000;
                        popups.push(new FloatingText(e.x, e.y, e.isBoss ? "BOSS DESTROYED!" : "ZERO!", "#00ffff", e.isBoss ? 25 : 20));
                        
                        if (!e.isBoss && Math.random() < 0.25) { // ドロップ率微増
                            // ランダムアイテム選出
                            const rand = Math.random();
                            let type = 'p';
                            if (rand < 0.25) type = 'p';
                            else if (rand < 0.5) type = 's';
                            else if (rand < 0.75) type = 'r';
                            else type = 'b';
                            
                            items.push(new Item(e.x, e.y, type));
                        }

                        for(let i=0; i< (e.isBoss ? 50 : 15); i++) particles.push(new Particle(e.x, e.y, '#ff0044', 8, 30));
                        
                        if (e.isBoss) {
                            bossActive = false;
                            bossHud.style.display = 'none';
                        }
                    } else {
                        popups.push(new FloatingText(e.x, e.y, "CRITICAL!", "#ff0", 10));
                        for(let i=0; i<3; i++) particles.push(new Particle(e.x, e.y, '#fff', 5, 10));
                    }

                } else if (impactDist < MID_DIST) {
                    if (e.isBoss) {
                        e.hp -= 0.2; 
                        AudioSys.playRicochet(); 
                    } else {
                        e.hp -= 1;
                        AudioSys.playHit();
                    }
                    
                    const angle = Math.atan2(e.y - player.y, e.x - player.x);
                    e.vx = Math.cos(angle) * (e.isBoss ? 2 : 8); 
                    e.vy = Math.sin(angle) * (e.isBoss ? 2 : 8);

                    if (e.hp <= 0 && !e.isBoss) {
                        score += 100;
                        popups.push(new FloatingText(e.x, e.y, "HIT", "#fff", 10));
                        for(let i=0; i<8; i++) particles.push(new Particle(e.x, e.y, '#ff0044', 4, 20));
                    }
                } else {
                    for(let i=0; i<2; i++) particles.push(new Particle(b.x, b.y, '#888', 2, 5));
                    AudioSys.playRicochet();
                    popups.push(new FloatingText(e.x, e.y - 20, "TOO FAR", "#555", 8));
                }
            }
        });
    });
    
    enemyBullets.forEach(b => {
        const dist = Math.hypot(player.x - b.x, player.y - b.y);
        if (dist < player.size/2 + b.size/2) {
             if (player.shield) {
                player.shield = false; 
                popups.push(new FloatingText(player.x, player.y, "BLOCK!", "#0ff", 15));
                AudioSys.playRicochet();
                b.dead = true;
                shakeIntensity = 5;
            } else {
                gameOver();
            }
        }
    });

    enemies = enemies.filter(e => e.hp > 0);
    particles.forEach(p => p.update());
    particles = particles.filter(p => p.life > 0);
    popups.forEach(p => p.update());
    popups = popups.filter(p => p.life > 0);

    if (bossActive) {
        const boss = enemies.find(e => e.isBoss);
        if (boss) {
            hpBarFill.style.width = `${(boss.hp / boss.maxHp) * 100}%`;
        }
    }

    if (shakeIntensity > 0) shakeIntensity *= 0.9;
    if (shakeIntensity < 0.5) shakeIntensity = 0;

    updateScoreDisplay();
    frameCount++;
}

function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, width, height);

    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x < width; x += 50) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
    for (let y = 0; y < height; y += 50) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
    ctx.stroke();

    ctx.save();
    if (shakeIntensity > 0) {
        const dx = (Math.random() - 0.5) * shakeIntensity;
        const dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
    }

    items.forEach(i => i.draw(ctx));
    bullets.forEach(b => b.draw(ctx));
    enemyBullets.forEach(b => b.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    enemies.forEach(e => e.draw(ctx));
    player.draw(ctx);
    popups.forEach(p => p.draw(ctx));

    if (Input.touch.active) {
        ctx.beginPath();
        ctx.arc(Input.touch.start.x, Input.touch.start.y, 40, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(Input.touch.curr.x, Input.touch.curr.y, 15, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.fill();
    }

    ctx.restore();
}

function gameOver() {
    currentState = STATE.GAMEOVER;
    
    let isNewRecord = false;
    if (score > highScore) {
        highScore = score;
        isNewRecord = true;
        try {
            localStorage.setItem('ZeroDistance_HighScore', highScore);
        } catch(e) {
            console.log("Failed to save high score");
        }
    }

    let newRecordHtml = isNewRecord ? '<p class="blink" style="color:#ffff00; margin-bottom:10px;">NEW RECORD!</p>' : '';
    let scoreHtml = `<p>SCORE: ${score}</p>`;
    let highScoreHtml = `<p style="font-size:12px; color:#aaa; margin-top:5px;">HI-SCORE: ${highScore}</p>`;

    screenContent.innerHTML = `
        <p style="color:red; font-size: 24px; margin-bottom:20px;">GAME OVER</p>
        ${newRecordHtml}
        ${scoreHtml}
        ${highScoreHtml}
        <div class="blink" style="margin-top:30px;">[ TRY AGAIN ]</div>
    `;
    overlayScreen.classList.remove('hidden');
    bossHud.style.display = 'none';
    warningOverlay.style.display = 'none';
    mobileShotBtn.style.display = 'none';
    shakeIntensity = 20;
    AudioSys.playExplosion();
}

function loop() {
    if (currentState === STATE.PLAYING || currentState === STATE.BOSS_WARNING) {
        requestAnimationFrame(loop);
        if (currentState === STATE.PLAYING) {
            update();
            draw();
        } else if (currentState === STATE.BOSS_WARNING) {
            draw(); // 背景でゲーム画面は出し続ける
        }
    }
}
</script>
</body>
</html>
