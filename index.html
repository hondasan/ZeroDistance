<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zero Distance v16 (Critical Break)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            color: #fff;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- CRT Effect --- */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
        
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 11;
        }

        /* --- UI Layer --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-header {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            text-shadow: 2px 2px 0 #000;
        }
        
        .score-box { text-align: left; }
        .score-label { font-size: 10px; color: #aaa; margin-bottom: 5px; display: block; }
        #score-display { font-size: 20px; color: #fff; }

        .status-box { text-align: right; }
        .status-label { font-size: 10px; color: #aaa; margin-bottom: 5px; }
        #shield-bar { 
            display: flex; 
            gap: 5px; 
            justify-content: flex-end;
        }
        .shield-pip {
            width: 15px;
            height: 15px;
            background: #00ffff;
            border: 2px solid #fff;
            box-shadow: 0 0 5px #0ff;
        }
        .shield-pip.empty {
            background: transparent;
            border-color: #444;
            box-shadow: none;
        }

        /* Boss HUD */
        #boss-hud {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            display: none;
            text-align: center;
        }
        .boss-name { font-size: 12px; color: #f00; margin-bottom: 5px; text-shadow: 1px 1px 0 #000; }
        .hp-bar-frame {
            width: 100%;
            height: 10px;
            background: #300;
            border: 2px solid #fff;
            margin-bottom: 5px;
            position: relative;
        }
        #hp-bar-fill {
            width: 100%;
            height: 100%;
            background: #f00;
            transition: width 0.1s;
        }
        /* Stun Gauge */
        .stun-bar-frame {
            width: 100%;
            height: 6px;
            background: #220;
            border: 1px solid #880;
        }
        #stun-bar-fill {
            width: 0%;
            height: 100%;
            background: #ff0;
            transition: width 0.1s;
        }
        .stun-label { font-size: 8px; color: #ff0; text-align: left; margin-bottom: 2px; }

        /* Warning Overlay */
        #warning-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 40px;
            text-align: center;
            display: none;
            text-shadow: 4px 4px 0 #000;
            width: 100%;
            background: rgba(0,0,0,0.5);
            padding: 20px 0;
        }
        .warning-blink { animation: warnBlink 0.08s infinite; }
        @keyframes warnBlink { 0% {opacity:1;} 50% {opacity:0;} 100% {opacity:1;} }

        /* Start / Game Over */
        #overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            min-width: 300px;
            z-index: 200;
        }

        h1 { font-size: 32px; margin: 0 0 20px 0; color: #fff; text-shadow: 4px 4px 0 #333; line-height: 1.2; }
        .subtitle { font-size: 12px; color: #f0f; margin-bottom: 30px; letter-spacing: 2px; text-transform: uppercase; }
        .instruction { font-size: 10px; color: #aaa; margin: 10px 0; line-height: 1.6; }
        .blink { animation: blinker 1s steps(2, start) infinite; color: #ffff00; font-size: 14px; margin-top: 30px; }
        @keyframes blinker { 50% { opacity: 0; } }
        
        .controls-guide {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 0 40px;
            box-sizing: border-box;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="ui-layer">
        <div class="hud-header">
            <div class="score-box">
                <span class="score-label">SCORE</span>
                <span id="score-display">000,000</span>
            </div>
            <div class="status-box">
                <div class="status-label">SHIELD</div>
                <div id="shield-bar"></div>
            </div>
        </div>

        <div id="warning-overlay">
            <div class="warning-blink">WARNING</div>
            <div id="boss-warning-name" style="font-size:16px; margin-top:10px; color:#fff;">HUGE ENERGY DETECTED</div>
        </div>

        <div id="boss-hud">
            <div id="boss-hud-name" class="boss-name">THE CORE</div>
            <div class="hp-bar-frame"><div id="hp-bar-fill"></div></div>
            <div class="stun-label">BREAK GAUGE (BREAK TO DEAL 4x DAMAGE!)</div>
            <div class="stun-bar-frame"><div id="stun-bar-fill"></div></div>
        </div>

        <div id="overlay-screen">
            <h1>ZERO<br>DISTANCE</h1>
            <div class="subtitle">Risk It All</div>
            <div id="screen-content">
                <div class="blink">[ LOADING... ]</div>
            </div>
            <div class="instruction" style="margin-top: 30px; font-size: 8px; color: #666;">
                <span style="color:#0ff">AUTO AIM ENABLED</span><br><br>
                PC: [SPACE] or [CLICK] to SHOOT<br>MOBILE: 2ND FINGER TAP to SHOOT
            </div>
        </div>

        <div class="controls-guide" id="mobile-guide" style="display:none;">
            <div style="margin-right: auto; margin-left: 20px;">DRAG: MOVE / TAP: SHOT</div>
        </div>
    </div>
</div>

<script>
/**
 * ------------------------------------------------------------------
 * SPRITES
 * ------------------------------------------------------------------
 */
const Sprites = {
    player: [
        [0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,0,1,1,0,1,0,1,1,0,0],
        [0,1,1,1,0,1,0,1,1,1,0],
        [0,1,1,0,0,1,0,0,1,1,0],
        [1,1,0,0,0,0,0,0,0,1,1],
        [1,0,0,0,0,0,0,0,0,0,1]
    ],
    // Enemy Sprites
    enemy: [
        [0,0,0,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,1,1,0],
        [1,1,0,1,1,1,1,1,0,1,1],
        [1,1,0,1,1,1,1,1,0,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [0,1,1,0,1,1,1,0,1,1,0],
        [0,1,1,1,0,0,0,1,1,1,0],
        [0,0,1,1,1,0,1,1,1,0,0],
        [0,0,1,0,1,0,1,0,1,0,0],
        [0,0,1,0,0,0,0,0,1,0,0]
    ],
    enemy_speed: [
        [0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,0],
        [0,1,0,0,1,1,1,0,0,1,0],
        [1,1,0,0,1,1,1,0,0,1,1],
        [1,0,0,0,1,1,1,0,0,0,1],
        [0,0,0,0,1,0,1,0,0,0,0],
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,0,0,1,0,0,0,1,0,0,0]
    ],
    enemy_tank: [
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,1,0,1,1,1,1,1,0,1,1],
        [1,1,0,1,1,1,1,1,0,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [0,1,1,0,0,0,0,0,1,1,0],
        [0,1,1,0,0,0,0,0,1,1,0],
        [0,1,1,1,0,0,0,1,1,1,0],
        [0,0,1,1,1,1,1,1,1,0,0]
    ],
    enemy_shooter: [
        [0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,0,1,1,0,0,0,1,1,0,0],
        [0,1,1,0,0,1,0,0,1,1,0],
        [1,1,0,0,1,1,1,0,0,1,1],
        [1,0,0,1,1,1,1,1,0,0,1],
        [1,0,1,1,0,0,0,1,1,0,1],
        [1,1,1,0,0,0,0,0,1,1,1],
        [0,1,0,0,0,0,0,0,0,1,0],
        [0,1,0,0,0,0,0,0,0,1,0]
    ],
    enemy_sniper: [
        [0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,0,0,0],
        [0,0,1,1,0,1,0,1,1,0,0],
        [0,1,1,1,1,1,1,1,1,1,0],
        [1,1,0,0,0,1,0,0,0,1,1],
        [1,0,0,0,0,1,0,0,0,0,1],
        [0,0,0,0,1,0,1,0,0,0,0],
        [0,0,0,0,1,0,1,0,0,0,0]
    ],
    enemy_splitter: [
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,0,1,0,0,1,1,0],
        [1,1,0,0,0,1,0,0,0,1,1],
        [1,0,0,0,1,1,1,0,0,0,1],
        [1,0,0,1,1,1,1,1,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,1,1,1,1,1,0,0,1],
        [1,0,0,0,1,1,1,0,0,0,1],
        [1,1,0,0,0,1,0,0,0,1,1],
        [0,1,1,0,0,1,0,0,1,1,0],
        [0,0,1,1,1,1,1,1,1,0,0]
    ],
    // New Enemies
    enemy_orbiter: [
        [0,0,0,1,1,1,0,0,0],
        [0,0,1,1,0,1,1,0,0],
        [0,1,1,0,0,0,1,1,0],
        [1,1,0,0,1,0,0,1,1],
        [1,0,0,1,1,1,0,0,1],
        [1,1,0,0,1,0,0,1,1],
        [0,1,1,0,0,0,1,1,0],
        [0,0,1,1,0,1,1,0,0],
        [0,0,0,1,1,1,0,0,0]
    ],
    enemy_mine: [
        [0,0,1,0,0,0,1,0,0],
        [0,0,0,1,0,1,0,0,0],
        [1,0,1,1,1,1,1,0,1],
        [0,1,1,1,1,1,1,1,0],
        [0,0,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,0],
        [1,0,1,1,1,1,1,0,1],
        [0,0,0,1,0,1,0,0,0],
        [0,0,1,0,0,0,1,0,0]
    ],
    boss_core: [
        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
        [0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0],
        [0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0],
        [0,1,1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,0],
        [1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0],
        [1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0],
        [1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,1,1,1,0,0],
        [1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0],
        [1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0],
        [0,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0],
        [0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0],
        [0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    boss_chaser: [
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0],
        [0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0],
        [0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,0],
        [0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0],
        [0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0],
        [0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    // New Boss: Titan (Big square)
    boss_titan: [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1],
        [1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1],
        [1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
        [1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1],
        [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1],
        [1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1],
        [1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    // 7x7 Items (Same as before)
    item_p: [
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,0,0,1,0,0,1],
        [1,0,0,1,0,0,1],
        [1,0,0,1,0,0,1],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0]
    ],
    item_s: [
        [0,0,1,1,1,0,0],
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,1,0,1,0,1,1],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0],
        [0,0,1,1,1,0,0]
    ],
    item_r: [
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,0,0,1,1,1,0],
        [1,0,0,1,1,0,0],
        [1,0,0,1,0,1,0],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0]
    ],
    item_b: [
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,0,0,1,1,0,1],
        [1,0,0,1,0,1,1],
        [1,0,0,1,1,0,1],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0]
    ],
    item_l: [ 
        [0,0,1,1,1,0,0],
        [0,1,1,1,1,1,0],
        [1,1,0,1,0,1,1],
        [1,1,0,1,0,1,1],
        [1,1,0,1,0,1,1],
        [0,1,1,1,1,1,0],
        [0,0,1,1,1,0,0]
    ],
    item_h: [ 
        [0,0,1,0,1,0,0],
        [0,1,1,1,1,1,0],
        [1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1],
        [0,1,1,1,1,1,0],
        [0,0,1,1,1,0,0],
        [0,0,0,1,0,0,0]
    ],
    item_w: [ 
        [0,1,1,1,1,1,0],
        [1,1,0,0,0,1,1],
        [1,0,1,0,1,0,1],
        [1,0,1,0,1,0,1],
        [1,0,1,1,1,0,1],
        [1,1,0,0,0,1,1],
        [0,1,1,1,1,1,0]
    ]
};

function drawPixelArt(ctx, pattern, pixelSize, color) {
    const rows = pattern.length;
    const cols = pattern[0].length;
    const offsetX = -(cols * pixelSize) / 2;
    const offsetY = -(rows * pixelSize) / 2;

    ctx.fillStyle = color;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (pattern[r][c] === 1) {
                ctx.fillRect(offsetX + c * pixelSize, offsetY + r * pixelSize, pixelSize, pixelSize);
            }
        }
    }
}

/**
 * ------------------------------------------------------------------
 * AUDIO SYSTEM
 * ------------------------------------------------------------------
 */
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    resume: function() {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot: function() {
        this.playTone(800, 'square', 0.05, 0.05);
        this.playTone(300, 'sawtooth', 0.05, 0.05);
    },
    playLaser: function() {
        this.playTone(1200, 'sawtooth', 0.2, 0.1);
        setTimeout(() => this.playTone(800, 'square', 0.2, 0.1), 50);
    },
    playRicochet: function() {
        this.playTone(1200, 'triangle', 0.1, 0.05);
    },
    playHit: function() {
        this.playTone(150, 'square', 0.1, 0.1);
    },
    playBreak: function() {
        this.playTone(1500, 'sawtooth', 0.3, 0.2);
        setTimeout(() => this.playTone(1000, 'square', 0.4, 0.2), 50);
        setTimeout(() => this.playTone(500, 'sawtooth', 0.5, 0.3), 100);
    },
    playPowerup: function() {
        this.playTone(600, 'sine', 0.1, 0.1);
        setTimeout(() => this.playTone(1200, 'square', 0.2, 0.1), 100);
    },
    playBomb: function() {
        if (!this.ctx) return;
        this.playTone(100, 'sawtooth', 0.5, 0.5);
        setTimeout(() => this.playTone(50, 'square', 0.5, 0.5), 100);
    },
    playWarning: function() {
        this.playTone(150, 'sawtooth', 0.2, 0.3);
        setTimeout(() => this.playTone(100, 'sawtooth', 0.2, 0.3), 100);
    },
    playExplosion: function() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.4;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
        this.playTone(50, 'sawtooth', 0.3, 0.3);
    }
};

/**
 * ------------------------------------------------------------------
 * GAME VARIABLES
 * ------------------------------------------------------------------
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score-display');
const shieldBar = document.getElementById('shield-bar'); 
const overlayScreen = document.getElementById('overlay-screen');
const screenContent = document.getElementById('screen-content');
const warningOverlay = document.getElementById('warning-overlay');
const bossWarningName = document.getElementById('boss-warning-name');
const bossHud = document.getElementById('boss-hud');
const bossHudName = document.getElementById('boss-hud-name');
const hpBarFill = document.getElementById('hp-bar-fill');
const stunBarFill = document.getElementById('stun-bar-fill'); 
const mobileGuide = document.getElementById('mobile-guide');

let width, height;
const isMobile = 'ontouchstart' in window;
if (isMobile) {
    mobileGuide.style.display = 'flex';
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    ctx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', resize);
resize();

const STATE = { TITLE: 0, PLAYING: 1, BOSS_WARNING: 2, GAMEOVER: 3 };
let currentState = STATE.TITLE;
let score = 0;
let highScore = 0;
let frameCount = 0;
let shakeIntensity = 0;
let freezeTimer = 0;
let nextBossScore = 3000;
let bossActive = false;

try {
    const saved = localStorage.getItem('ZeroDistance_HighScore');
    if (saved) highScore = parseInt(saved, 10);
} catch(e) { console.log("LS Error"); }

function showTitleScreen() {
    currentState = STATE.TITLE;
    screenContent.innerHTML = `
        <p class="instruction" style="color:#f88;">KILL AT ZERO RANGE.</p>
        <p class="instruction">BREAK BOSS ARMOR FROM AFAR.</p>
        <p style="margin-top:20px; color:#ffff00; font-size:12px;">HI-SCORE: ${highScore.toLocaleString()}</p>
        <div class="blink" style="margin-top:30px;">[ TAP TO START ]</div>
    `;
    overlayScreen.classList.remove('hidden');
    bossHud.style.display = 'none';
    warningOverlay.style.display = 'none';
}

showTitleScreen();

const Input = {
    keys: {},
    mouse: { x: 0, y: 0, down: false },
    shot: { down: false },
    touch: {
        moveId: null, // 移動用タッチID
        shotId: null, // ショット用タッチID
        start: {x:0, y:0},
        curr: {x:0, y:0}
    }
};

window.addEventListener('keydown', e => {
    Input.keys[e.key] = true;
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') Input.shot.down = true;
});
window.addEventListener('keyup', e => {
    Input.keys[e.key] = false;
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') Input.shot.down = false;
});
window.addEventListener('mousemove', e => { Input.mouse.x = e.clientX; Input.mouse.y = e.clientY; });
window.addEventListener('mousedown', () => Input.shot.down = true);
window.addEventListener('mouseup', () => Input.shot.down = false);

// Multi-touch Handler for "Move & Shot"
window.addEventListener('touchstart', e => {
    if (e.target.closest('#overlay-screen')) return; 
    e.preventDefault();
    
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        
        // 最初のタッチは移動に割り当て
        if (Input.touch.moveId === null) {
            Input.touch.moveId = t.identifier;
            Input.touch.start = { x: t.clientX, y: t.clientY };
            Input.touch.curr = { x: t.clientX, y: t.clientY };
        } 
        // 2本目のタッチはショットに割り当て（場所問わず）
        else if (Input.touch.shotId === null) {
            Input.touch.shotId = t.identifier;
            Input.shot.down = true;
        }
    }
}, { passive: false });

window.addEventListener('touchmove', e => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === Input.touch.moveId) {
            Input.touch.curr = { x: t.clientX, y: t.clientY };
        }
    }
}, { passive: false });

window.addEventListener('touchend', e => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === Input.touch.moveId) {
            Input.touch.moveId = null;
        }
        if (t.identifier === Input.touch.shotId) {
            Input.touch.shotId = null;
            Input.shot.down = false;
        }
    }
}, { passive: false });

const handleStartInteraction = (e) => {
    e.stopPropagation();
    if(e.cancelable && e.type === 'touchstart') e.preventDefault();

    if (currentState !== STATE.PLAYING && currentState !== STATE.BOSS_WARNING) {
        startGame();
    }
};

overlayScreen.addEventListener('mousedown', handleStartInteraction);
overlayScreen.addEventListener('touchstart', handleStartInteraction, { passive: false });

function startGame() {
    AudioSys.init();
    AudioSys.resume();
    
    player = new Player();
    enemies = [];
    bullets = [];
    enemyBullets = [];
    particles = [];
    popups = [];
    items = [];
    score = 0;
    shakeIntensity = 0;
    freezeTimer = 0;
    frameCount = 0;
    nextBossScore = 3000;
    bossActive = false;
    
    updateScoreDisplay();
    overlayScreen.classList.add('hidden');
    bossHud.style.display = 'none';
    warningOverlay.style.display = 'none';
    currentState = STATE.PLAYING;
    loop();
}

function updateScoreDisplay() {
    scoreEl.innerText = score.toLocaleString().padStart(6, '0');
    // Shield UI
    shieldBar.innerHTML = '';
    if (player) {
        for(let i=0; i<3; i++) {
            const pip = document.createElement('div');
            pip.className = 'shield-pip' + (i < player.shield ? '' : ' empty');
            shieldBar.appendChild(pip);
        }
    }
}

function spawnBoss() {
    currentState = STATE.BOSS_WARNING;
    warningOverlay.style.display = 'block';
    
    const r = Math.random();
    let type = 0; // Core
    if (r < 0.33) type = 0;
    else if (r < 0.66) type = 1; // Chaser
    else type = 2; // Titan (New)

    let name = "THE CORE";
    if (type === 1) name = "THE CHASER";
    if (type === 2) name = "THE TITAN";

    bossWarningName.innerText = `WARNING: ${name}`;
    bossHudName.innerText = name;

    let count = 0;
    const interval = setInterval(() => {
        AudioSys.playWarning();
        count++;
        if (count > 3) {
            clearInterval(interval);
            setTimeout(() => {
                warningOverlay.style.display = 'none';
                currentState = STATE.PLAYING;
                bossActive = true;
                enemies.push(new Boss(type));
                bossHud.style.display = 'block';
            }, 200);
        }
    }, 150);
}

/**
 * ------------------------------------------------------------------
 * CLASSES
 * ------------------------------------------------------------------
 */
class Player {
    constructor() {
        this.x = width / 2;
        this.y = height / 2;
        this.pixelSize = 3; 
        this.size = 11 * this.pixelSize;
        this.speed = 4;
        this.angle = 0; 
        this.color = '#00ffff'; 
        this.shootCooldown = 0;
        this.powerUpTimer = 0;
        this.rapidTimer = 0;
        this.laserTimer = 0; 
        this.wideTimer = 0;  
        this.shield = 1;     
        this.dead = false; 
    }

    update() {
        if (this.dead) return;

        let dx = 0;
        let dy = 0;
        if (Input.keys['w'] || Input.keys['ArrowUp']) dy -= 1;
        if (Input.keys['s'] || Input.keys['ArrowDown']) dy += 1;
        if (Input.keys['a'] || Input.keys['ArrowLeft']) dx -= 1;
        if (Input.keys['d'] || Input.keys['ArrowRight']) dx += 1;

        if (Input.touch.moveId !== null) {
            const tx = Input.touch.curr.x - Input.touch.start.x;
            const ty = Input.touch.curr.y - Input.touch.start.y;
            const dist = Math.hypot(tx, ty);
            const deadZone = 10;
            if (dist > deadZone) {
                dx = tx / dist;
                dy = ty / dist;
                const speedFactor = Math.min(dist / 50, 1.0);
                dx *= speedFactor;
                dy *= speedFactor;
            }
        }

        if (Input.touch.moveId === null && (dx !== 0 || dy !== 0)) {
            const length = Math.hypot(dx, dy);
            if (length > 1) { 
                dx /= length;
                dy /= length;
            }
        }

        this.x += dx * this.speed;
        this.y += dy * this.speed;
        this.x = Math.max(this.size, Math.min(width - this.size, this.x));
        this.y = Math.max(this.size, Math.min(height - this.size, this.y));

        if (this.shootCooldown > 0) this.shootCooldown--;
        if (this.powerUpTimer > 0) this.powerUpTimer--;
        if (this.rapidTimer > 0) this.rapidTimer--;
        if (this.laserTimer > 0) this.laserTimer--;
        if (this.wideTimer > 0) this.wideTimer--;
        
        let nearestEnemy = null;
        let minDist = Infinity;
        const rangeLimit = Math.max(width, height) * 0.9; 

        enemies.forEach(e => {
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < minDist && d < rangeLimit) {
                minDist = d;
                nearestEnemy = e;
            }
        });

        if (nearestEnemy) {
            this.angle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
        } else if (dx !== 0 || dy !== 0) {
            this.angle = Math.atan2(dy, dx);
        }

        if (Input.shot.down && this.shootCooldown <= 0) {
            this.shoot();
            this.shootCooldown = this.rapidTimer > 0 ? 3 : (this.laserTimer > 0 ? 25 : 8);
        }
    }

    shoot() {
        const spread = (Math.random() - 0.5) * 0.1;
        
        if (this.laserTimer > 0) {
            // Laser Shot - buffed damage in bullet class
            bullets.push(new Bullet(this.x, this.y, this.angle, true)); // piercing
            AudioSys.playLaser();
            shakeIntensity = 5;
            this.x -= Math.cos(this.angle) * 8; // Heavy recoil
            this.y -= Math.sin(this.angle) * 8;
        } else if (this.wideTimer > 0) {
            // 5-Way Wide
            for(let i = -2; i <= 2; i++) {
                bullets.push(new Bullet(this.x, this.y, this.angle + spread + (i * 0.15)));
            }
            AudioSys.playShoot();
            this.x -= Math.cos(this.angle) * 3;
            this.y -= Math.sin(this.angle) * 3;
        } else if (this.powerUpTimer > 0) {
            // 3-Way
            bullets.push(new Bullet(this.x, this.y, this.angle + spread));
            bullets.push(new Bullet(this.x, this.y, this.angle + spread + 0.3));
            bullets.push(new Bullet(this.x, this.y, this.angle + spread - 0.3));
            AudioSys.playShoot();
            this.x -= Math.cos(this.angle) * 2;
            this.y -= Math.sin(this.angle) * 2;
        } else {
            // Normal
            bullets.push(new Bullet(this.x, this.y, this.angle + spread));
            AudioSys.playShoot();
            this.x -= Math.cos(this.angle) * 2;
            this.y -= Math.sin(this.angle) * 2;
        }
    }

    draw(ctx) {
        if (this.dead) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2);
        
        let color = this.color;
        if (this.shield > 0) color = '#ffffff';
        else if (this.laserTimer > 0) color = '#0088ff';
        else if (this.rapidTimer > 0 && frameCount % 4 < 2) color = '#ff8800'; 
        
        drawPixelArt(ctx, Sprites.player, this.pixelSize, color);
        
        if (this.shield > 0) {
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(100, 255, 255, ${0.3 + (this.shield * 0.2)})`;
            ctx.lineWidth = 1 + this.shield;
            ctx.stroke();
        }
        ctx.restore();
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, 90, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

class Enemy {
    constructor(type = 0) {
        this.type = type; // 0:Normal, 1:Speed, 2:Tank, 3:Shooter, 4:Sniper, 5:Splitter, 6:Orbiter, 7:Mine
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { this.x = Math.random() * width; this.y = -50; }
        else if (edge === 1) { this.x = width + 50; this.y = Math.random() * height; }
        else if (edge === 2) { this.x = Math.random() * width; this.y = height + 50; }
        else { this.x = -50; this.y = Math.random() * height; }

        this.pixelSize = 3;
        this.size = 13 * this.pixelSize;
        this.speed = 1.0 + Math.random() * 2.0;
        this.angle = 0;
        this.hp = 3;
        this.color = '#ff0044';
        this.vx = 0; 
        this.vy = 0;
        this.isBoss = false;
        this.shootTimer = 0;
        this.isZeroDist = false;

        // Apply Type Config
        if (this.type === 1) { // Speedster
            this.speed = 4.0 + Math.random();
            this.hp = 2;
            this.color = '#0088ff';
            this.sprite = Sprites.enemy_speed;
        } else if (this.type === 2) { // Tank
            this.speed = 0.8;
            this.hp = 8;
            this.color = '#00ff00';
            this.size = 15 * this.pixelSize;
            this.sprite = Sprites.enemy_tank;
        } else if (this.type === 3) { // Shooter
            this.speed = 1.2;
            this.hp = 3;
            this.color = '#ffff00';
            this.sprite = Sprites.enemy_shooter;
        } else if (this.type === 4) { // Sniper
            this.speed = 1.5;
            this.hp = 4;
            this.color = '#aa00ff';
            this.sprite = Sprites.enemy_sniper;
        } else if (this.type === 5) { // Splitter
            this.speed = 1.0;
            this.hp = 5;
            this.color = '#ff8800';
            this.sprite = Sprites.enemy_splitter;
        } else if (this.type === 6) { // Orbiter
            this.speed = 2.0;
            this.hp = 3;
            this.color = '#00ffff';
            this.sprite = Sprites.enemy_orbiter;
            this.orbitAngle = Math.random() * Math.PI * 2;
        } else if (this.type === 7) { // Mine
            this.speed = 0;
            this.hp = 5;
            this.color = '#888888';
            this.sprite = Sprites.enemy_mine;
            this.x = Math.random() * (width - 100) + 50; // Random spawn inside
            this.y = Math.random() * (height - 100) + 50;
        } else { // Normal
            this.sprite = Sprites.enemy;
        }
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.9;
        this.vy *= 0.9;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        this.angle = Math.atan2(dy, dx);
        
        let moveSpeed = this.speed;
        const dist = Math.hypot(dx, dy);

        // Logic based on Type
        if (this.type === 3) { // Shooter
            if (dist < 300) moveSpeed = -1;
            else if (dist < 400) moveSpeed = 0;
            
            this.shootTimer++;
            if (this.shootTimer > 120) {
                enemyBullets.push(new EnemyBullet(this.x, this.y, this.angle));
                this.shootTimer = 0;
            }
        } else if (this.type === 4) { // Sniper
            if (dist < 500) moveSpeed = -1.5;
            else if (dist < 600) moveSpeed = 0;
            
            this.shootTimer++;
            if (this.shootTimer > 180) { 
                let b = new EnemyBullet(this.x, this.y, this.angle);
                b.speed = 8; 
                b.size = 4;
                enemyBullets.push(b);
                this.shootTimer = 0;
            }
        } else if (this.type === 6) { // Orbiter
            this.orbitAngle += 0.02;
            const targetX = player.x + Math.cos(this.orbitAngle) * 150;
            const targetY = player.y + Math.sin(this.orbitAngle) * 150;
            const odx = targetX - this.x;
            const ody = targetY - this.y;
            const oAngle = Math.atan2(ody, odx);
            this.x += Math.cos(oAngle) * this.speed;
            this.y += Math.sin(oAngle) * this.speed;
            
            this.shootTimer++;
            if (this.shootTimer > 150) {
                enemyBullets.push(new EnemyBullet(this.x, this.y, this.angle));
                this.shootTimer = 0;
            }
            return; // Skip normal movement
        } else if (this.type === 7) { // Mine
            // Do nothing, just sit there. Explode if close?
            if (dist < 80) {
                // Warning flash?
                if (frameCount % 10 < 5) this.color = '#ff0000';
                else this.color = '#888888';
            }
            return;
        }

        this.x += Math.cos(this.angle) * moveSpeed;
        this.y += Math.sin(this.angle) * moveSpeed;

        this.isZeroDist = (dist < 90);
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2);
        
        let drawColor = this.color;
        if (this.hp < 3 && frameCount % 4 < 2) drawColor = '#ffffff';
        if (this.isZeroDist && frameCount % 4 < 2) drawColor = '#ff00ff';

        drawPixelArt(ctx, this.sprite, this.pixelSize, drawColor);
        ctx.restore();

        if (this.isZeroDist) {
            ctx.save();
            ctx.translate(this.x, this.y - 30);
            ctx.fillStyle = "#ff00ff";
            ctx.font = "8px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText("LOCK", 0, 0);
            ctx.restore();
        }
    }
}

class Boss extends Enemy {
    constructor(type = 0) {
        super(0);
        this.bossType = type; // 0:Core, 1:Chaser, 2:Titan
        this.x = width / 2;
        this.y = -200; 
        this.pixelSize = 6; 
        this.size = 25 * this.pixelSize;
        // Boss HP Reduced
        this.hp = 250;
        this.maxHp = 250;
        this.speed = 1.0;
        this.color = '#aa00ff';
        this.isBoss = true;
        this.shootTimer = 0;
        this.entering = true; 
        this.dropped50 = false; 
        this.dropped20 = false;
        
        // --- Stun System ---
        this.stun = 0;
        this.maxStun = 100;
        this.isStunned = false;
        this.stunTimer = 0;

        if (this.bossType === 1) { // CHASER
            this.speed = 2.5; 
            this.color = '#ff3300';
            this.sprite = Sprites.boss_chaser;
            this.state = 'chase'; 
            this.stateTimer = 0;
        } else if (this.bossType === 2) { // TITAN
            this.speed = 0.5;
            this.hp = 400; // Reduced from 500
            this.maxHp = 400;
            this.color = '#444444';
            this.sprite = Sprites.boss_titan;
        } else { 
            this.sprite = Sprites.boss_core;
        }
    }

    update() {
        if (this.entering) {
            this.y += 5; 
            if (this.y > 150) {
                this.entering = false;
            }
            return; 
        }

        // Stun Logic
        if (this.isStunned) {
            this.stunTimer--;
            if (this.stunTimer <= 0) {
                this.isStunned = false;
                this.stun = 0;
                popups.push(new FloatingText(this.x, this.y - 60, "RECOVER!", "#fff", 15));
            }
            this.x += (Math.random()-0.5) * 2;
            this.y += (Math.random()-0.5) * 2;
            return; 
        } else {
            if (this.stun > 0) this.stun -= 0.1;
        }

        // Drops
        const hpPercent = this.hp / this.maxHp;
        if (!this.dropped50 && hpPercent <= 0.5) {
            this.dropped50 = true;
            items.push(new Item(this.x, this.y, 'h')); 
            AudioSys.playPowerup();
        }
        if (!this.dropped20 && hpPercent <= 0.2) {
            this.dropped20 = true;
            items.push(new Item(this.x, this.y, Math.random()>0.5 ? 'b' : 'l')); 
            AudioSys.playPowerup();
        }

        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.9;
        this.vy *= 0.9;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        this.angle = Math.atan2(dy, dx);

        if (this.bossType === 0) { // CORE
            const dist = Math.hypot(dx, dy);
            if (dist > 200) {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            } else {
                 this.x -= Math.cos(this.angle) * (this.speed * 0.5);
                 this.y -= Math.sin(this.angle) * (this.speed * 0.5);
            }
            this.shootTimer++;
            if (this.shootTimer > 50) { 
                this.shootCore();
                this.shootTimer = 0;
            }
        } else if (this.bossType === 1) { // CHASER
            this.stateTimer++;
            if (this.state === 'chase') {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                if (this.stateTimer > 240) { 
                    this.state = 'tired';
                    this.stateTimer = 0;
                    this.color = '#555555'; 
                }
            } else { 
                this.x += Math.cos(this.angle) * 0.2;
                this.y += Math.sin(this.angle) * 0.2;
                if (this.stateTimer > 180) { 
                    this.state = 'chase';
                    this.stateTimer = 0;
                    this.color = '#ff3300';
                }
            }
            if (frameCount % 100 === 0 && this.state === 'chase') {
                 for(let i=-1; i<=1; i++) {
                    enemyBullets.push(new EnemyBullet(this.x, this.y, this.angle + i*0.2));
                }
            }
        } else if (this.bossType === 2) { // TITAN
            const distToCenter = Math.hypot(width/2 - this.x, height/2 - this.y);
            if (distToCenter > 50) {
                const angleToCenter = Math.atan2(height/2 - this.y, width/2 - this.x);
                this.x += Math.cos(angleToCenter) * this.speed;
                this.y += Math.sin(angleToCenter) * this.speed;
            }
            
            this.shootTimer++;
            if (this.shootTimer > 90) {
                for(let i=0; i<8; i++) {
                    let b = new EnemyBullet(this.x, this.y, (Math.PI*2/8)*i + frameCount*0.01);
                    b.size = 10;
                    b.speed = 3;
                    enemyBullets.push(b);
                }
                if (Math.random() < 0.3) {
                    let m = new Enemy(7);
                    m.x = this.x + (Math.random()-0.5)*100;
                    m.y = this.y + (Math.random()-0.5)*100;
                    enemies.push(m);
                }
                this.shootTimer = 0;
                AudioSys.playShoot();
            }
        }

        this.x = Math.max(this.size, Math.min(width - this.size, this.x));
        this.y = Math.max(this.size, Math.min(height - this.size, this.y));
        
        const dist = Math.hypot(dx, dy);
        this.isZeroDist = (dist < 120); 
    }

    shootCore() {
        const count = 12;
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 / count) * i + (frameCount * 0.05); 
            let b = new EnemyBullet(this.x, this.y, angle);
            b.speed = 3.5; 
            enemyBullets.push(b);
        }
        AudioSys.playShoot();
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2);
        
        let drawColor = this.color;
        if (this.entering) {
            ctx.globalAlpha = 0.5; 
        } else if (this.isStunned) {
            drawColor = frameCount % 4 < 2 ? '#00ffff' : '#0000ff';
        } else {
            if (this.hp < 100 && frameCount % 6 < 3) drawColor = '#ff0000';
            if (this.isZeroDist && frameCount % 4 < 2) drawColor = '#ffffff'; 
            if (this.bossType === 1 && this.state === 'tired') {
                 if (frameCount % 20 < 10) drawColor = '#888888';
            }
        }
        
        drawPixelArt(ctx, this.sprite, this.pixelSize, drawColor);
        ctx.globalAlpha = 1.0;
        ctx.restore();

        if (this.isZeroDist && !this.entering) {
            ctx.save();
            ctx.translate(this.x, this.y - 70);
            ctx.fillStyle = "#ff00ff";
            ctx.font = "12px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText("LOCK!", 0, 0);
            ctx.restore();
        }
        
        if (this.isStunned) {
            ctx.save();
            ctx.translate(this.x, this.y + 70);
            ctx.fillStyle = "#00ffff";
            ctx.font = "14px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText("BREAK!!", 0, 0);
            ctx.restore();
        } else if (this.bossType === 1 && this.state === 'tired') {
            ctx.save();
            ctx.translate(this.x, this.y + 70);
            ctx.fillStyle = "#00ff00";
            ctx.font = "10px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText("CHANCE!", 0, 0);
            ctx.restore();
        }
    }
}

class Bullet {
    constructor(x, y, angle, piercing = false) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = piercing ? 20 : 14;
        this.life = piercing ? 30 : 50;
        this.dead = false;
        this.piercing = piercing;
        this.size = piercing ? 8 : 4;
        this.damage = piercing ? 15 : 1; // Buffed Laser Damage
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        if (this.life <= 0) this.dead = true;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        if (this.piercing) {
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-20, -2, 40, 4); 
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#00ffff";
        } else {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(-8, -1.5, 16, 3);
        }
        ctx.restore();
        ctx.shadowBlur = 0;
    }
}

class EnemyBullet {
    constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 4;
        this.life = 200;
        this.dead = false;
        this.size = 8;
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.dead = true;
    }
    draw(ctx) {
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
        ctx.fill();
    }
}

class Item {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; 
        this.life = 600; 
        this.pixelSize = 3;
        this.size = 20;
    }
    update() {
        this.life--;
        this.y += Math.sin(frameCount * 0.1) * 0.5;
    }
    draw(ctx) {
        if (this.life < 100 && this.life % 10 < 5) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        let sprite, color;
        switch(this.type) {
            case 'p': sprite = Sprites.item_p; color = '#ffaa00'; break;
            case 's': sprite = Sprites.item_s; color = '#00aaff'; break;
            case 'r': sprite = Sprites.item_r; color = '#ff4400'; break;
            case 'b': sprite = Sprites.item_b; color = '#aa00ff'; break;
            case 'l': sprite = Sprites.item_l; color = '#00ffff'; break;
            case 'h': sprite = Sprites.item_h; color = '#00ff88'; break; 
            case 'w': sprite = Sprites.item_w; color = '#ffff00'; break;
        }
        drawPixelArt(ctx, sprite, this.pixelSize, color);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = life;
        this.maxLife = life;
        this.size = Math.random() * 6 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.vx *= 0.92;
        this.vy *= 0.92;
        this.size *= 0.95;
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
    }
}

class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 50;
        this.size = size;
        this.vy = -0.5;
    }
    update() {
        this.y += this.vy;
        this.life--;
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.min(1, this.life / 10);
        ctx.fillStyle = this.color;
        ctx.font = `${this.size}px "Press Start 2P"`; 
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

let player;
let enemies = [];
let bullets = [];
let enemyBullets = [];
let items = [];
let particles = [];
let popups = [];

function update() {
    if (freezeTimer > 0) {
        freezeTimer--;
        return;
    }

    if (!bossActive && score >= nextBossScore) {
        spawnBoss();
        nextBossScore += 8000; // Increased interval
        return; 
    }

    if (!bossActive) {
        if (frameCount % Math.max(20, 60 - Math.floor(frameCount / 500)) === 0) {
            let type = 0;
            const r = Math.random();
            if (r < 0.3) type = 0; 
            else if (r < 0.5) type = 1; 
            else if (r < 0.6) type = 2; 
            else if (r < 0.7) type = 3; 
            else if (r < 0.8) type = 4; 
            else if (r < 0.9) type = 5; 
            else if (r < 0.95) type = 6; 
            else type = 7; 
            
            enemies.push(new Enemy(type));
        }
    }

    player.update();

    bullets.forEach(b => b.update());
    bullets = bullets.filter(b => !b.dead);
    
    enemyBullets.forEach(b => b.update());
    enemyBullets = enemyBullets.filter(b => !b.dead);

    items.forEach(i => i.update());
    items = items.filter(i => i.life > 0);
    
    items.forEach(item => {
        const dist = Math.hypot(player.x - item.x, player.y - item.y);
        if (dist < player.size + item.size) {
            item.life = 0;
            AudioSys.playPowerup();
            
            if (item.type === 'p') {
                player.powerUpTimer = 900; // Extended
                popups.push(new FloatingText(player.x, player.y - 30, "TRIPLE!", "#fa0", 12));
            } else if (item.type === 's') {
                player.shield = Math.min(player.shield + 1, 3); 
                popups.push(new FloatingText(player.x, player.y - 30, "SHIELD UP!", "#0af", 12));
            } else if (item.type === 'r') {
                player.rapidTimer = 900; // Extended
                popups.push(new FloatingText(player.x, player.y - 30, "RAPID!", "#f40", 12));
            } else if (item.type === 'b') {
                AudioSys.playBomb();
                shakeIntensity = 20;
                enemyBullets = []; 
                enemies.forEach(e => {
                    let dmg = 5;
                    if(e.isBoss) dmg = 50; // Bomb damage buff against boss
                    e.hp -= dmg;
                    const angle = Math.atan2(e.y - player.y, e.x - player.x);
                    e.vx = Math.cos(angle) * 20;
                    e.vy = Math.sin(angle) * 20;
                    for(let i=0; i<5; i++) particles.push(new Particle(e.x, e.y, '#fff', 5, 20));
                });
                popups.push(new FloatingText(player.x, player.y - 40, "EMP BLAST!", "#d0f", 16));
                for(let i=0; i<20; i++) {
                    particles.push(new Particle(Math.random()*width, Math.random()*height, '#a0f', 10, 30));
                }
            } else if (item.type === 'l') { 
                player.laserTimer = 600; // Extended
                popups.push(new FloatingText(player.x, player.y - 30, "LASER!", "#0ff", 14));
            } else if (item.type === 'h') { 
                player.shield = 3;
                popups.push(new FloatingText(player.x, player.y - 30, "FULL REPAIR!", "#0f8", 12));
            } else if (item.type === 'w') { 
                player.wideTimer = 900; // Extended
                popups.push(new FloatingText(player.x, player.y - 30, "WIDE SHOT!", "#ff0", 12));
            }
        }
    });

    enemies.forEach((e) => {
        e.update();
        
        if (e.isBoss && e.entering) return;

        const distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
        if (!player.dead && distToPlayer < (player.size/2 + e.size/2)) {
            if (player.shield > 0) {
                player.shield--; 
                popups.push(new FloatingText(player.x, player.y, "SHIELD LOST!", "#0ff", 10));
                AudioSys.playRicochet();
                const angle = Math.atan2(e.y - player.y, e.x - player.x);
                e.vx = Math.cos(angle) * 15;
                e.vy = Math.sin(angle) * 15;
                e.hp -= 1;
                enemyBullets = [];
                shakeIntensity = 10;
            } else {
                triggerGameOver(); 
            }
        }

        bullets.forEach(b => {
            if (b.dead) return;
            const distToBullet = Math.hypot(e.x - b.x, e.y - b.y);
            const hitRadius = e.isBoss ? e.size/2 : e.size/2 + 5;
            
            if (distToBullet < hitRadius) {
                if (!b.piercing) b.dead = true; 
                
                const impactDist = Math.hypot(player.x - e.x, player.y - e.y);
                const ZERO_DIST = e.isBoss ? 120 : 90; 
                const MID_DIST = 350; 
                
                if (impactDist < ZERO_DIST || (e.isBoss && e.isStunned)) {
                    // ZERO DISTANCE or STUNNED BONUS
                    let damage = 5;
                    if (b.piercing) damage = b.damage; 
                    if (!e.isBoss) damage = 100;
                    
                    if (e.isBoss && e.isStunned) damage *= 4; // Critical Break!

                    e.hp -= damage;
                    
                    if (e.isBoss) {
                        shakeIntensity = 5; 
                        AudioSys.playHit();
                        particles.push(new Particle(e.x, e.y, '#ffffff', 2, 5));
                    }

                    if (e.hp <= 0) {
                        freezeTimer = e.isBoss ? 30 : 8; 
                        shakeIntensity = e.isBoss ? 40 : 15;
                        AudioSys.playExplosion();
                        score += e.isBoss ? 5000 : 1000;
                        popups.push(new FloatingText(e.x, e.y, e.isBoss ? "BOSS DESTROYED!" : "ZERO!", "#00ffff", e.isBoss ? 25 : 20));
                        
                        if (!e.isBoss) {
                             if (Math.random() < 0.20) { 
                                const rand = Math.random();
                                let type = 'p';
                                if (rand < 0.15) type = 'p';
                                else if (rand < 0.30) type = 'w';
                                else if (rand < 0.45) type = 'r';
                                else if (rand < 0.60) type = 's';
                                else if (rand < 0.70) type = 'b';
                                else if (rand < 0.85) type = 'h'; 
                                else type = 'l'; 
                                
                                items.push(new Item(e.x, e.y, type));
                            }
                        }

                        for(let i=0; i< (e.isBoss ? 50 : 15); i++) particles.push(new Particle(e.x, e.y, '#ff0044', 8, 30));
                        
                        if (e.isBoss) {
                            bossActive = false;
                            bossHud.style.display = 'none';
                        }
                    } else {
                        if (e.isBoss && e.isStunned) {
                             popups.push(new FloatingText(e.x, e.y, "SMASH!!", "#fff", 12));
                        } else {
                             popups.push(new FloatingText(e.x, e.y, "CRITICAL!", "#ff0", 10));
                        }
                        for(let i=0; i<3; i++) particles.push(new Particle(e.x, e.y, '#fff', 5, 10));
                    }

                } else if (impactDist < MID_DIST) {
                    if (e.isBoss) {
                        if (!e.isStunned) {
                            e.stun += 3; // Stun faster
                            if (e.stun >= e.maxStun) {
                                e.stun = e.maxStun;
                                e.isStunned = true;
                                e.stunTimer = 180; 
                                AudioSys.playBreak();
                                popups.push(new FloatingText(e.x, e.y - 40, "ARMOR BREAK!!", "#0ff", 20));
                                shakeIntensity = 10;
                            }
                        }
                        e.hp -= 0.5; 
                        AudioSys.playRicochet(); 
                    } else {
                        e.hp -= 1;
                        AudioSys.playHit();
                    }
                    
                    const angle = Math.atan2(e.y - player.y, e.x - player.x);
                    if (!e.isBoss || e.isStunned) {
                         e.vx = Math.cos(angle) * (e.isBoss ? 0 : 8); 
                         e.vy = Math.sin(angle) * (e.isBoss ? 0 : 8);
                    }

                    if (e.hp <= 0 && !e.isBoss) {
                        score += 100;
                        popups.push(new FloatingText(e.x, e.y, "HIT", "#fff", 10));
                        for(let i=0; i<8; i++) particles.push(new Particle(e.x, e.y, '#ff0044', 4, 20));
                    }
                } else {
                    if (!b.piercing) {
                        for(let i=0; i<2; i++) particles.push(new Particle(b.x, b.y, '#888', 2, 5));
                        AudioSys.playRicochet();
                        popups.push(new FloatingText(e.x, e.y - 20, "TOO FAR", "#555", 8));
                    }
                }
            }
        });
    });
    
    enemyBullets.forEach(b => {
        const dist = Math.hypot(player.x - b.x, player.y - b.y);
        if (!player.dead && dist < player.size/2 + b.size/2) {
             if (player.shield > 0) {
                player.shield--; 
                popups.push(new FloatingText(player.x, player.y, "SHIELD LOST!", "#0ff", 10));
                AudioSys.playRicochet();
                b.dead = true;
                shakeIntensity = 10;
            } else {
                triggerGameOver(); 
            }
        }
    });

    enemies = enemies.filter(e => e.hp > 0);
    particles.forEach(p => p.update());
    particles = particles.filter(p => p.life > 0);
    popups.forEach(p => p.update());
    popups = popups.filter(p => p.life > 0);

    if (bossActive) {
        const boss = enemies.find(e => e.isBoss);
        if (boss) {
            hpBarFill.style.width = `${(boss.hp / boss.maxHp) * 100}%`;
            let stunPct = (boss.stun / boss.maxStun) * 100;
            if (boss.isStunned) stunPct = (boss.stunTimer / 180) * 100;
            stunBarFill.style.width = `${stunPct}%`;
            stunBarFill.style.background = boss.isStunned ? '#0ff' : '#ff0';
        }
    }

    if (shakeIntensity > 0) shakeIntensity *= 0.9;
    if (shakeIntensity < 0.5) shakeIntensity = 0;

    updateScoreDisplay();
    frameCount++;
}

function draw() {
    if (player.dead) ctx.fillStyle = '#300';
    else ctx.fillStyle = '#111';
    
    ctx.fillRect(0, 0, width, height);

    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x < width; x += 50) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
    for (let y = 0; y < height; y += 50) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
    ctx.stroke();

    ctx.save();
    if (shakeIntensity > 0) {
        const dx = (Math.random() - 0.5) * shakeIntensity;
        const dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
    }

    items.forEach(i => i.draw(ctx));
    bullets.forEach(b => b.draw(ctx));
    enemyBullets.forEach(b => b.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    enemies.forEach(e => e.draw(ctx));
    player.draw(ctx);
    popups.forEach(p => p.draw(ctx));

    if (Input.touch.moveId !== null) {
        ctx.beginPath();
        ctx.arc(Input.touch.start.x, Input.touch.start.y, 40, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(Input.touch.curr.x, Input.touch.curr.y, 15, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.fill();
    }

    ctx.restore();
}

function triggerGameOver() {
    if (player.dead) return;
    player.dead = true;
    freezeTimer = 30; // 長めのストップ（0.5秒）
    shakeIntensity = 50; // 激しい揺れ
    AudioSys.playExplosion();
    // 死亡エフェクト
    for(let i=0; i<30; i++) {
        particles.push(new Particle(player.x, player.y, '#00ffff', 10, 50));
        particles.push(new Particle(player.x, player.y, '#ffffff', 5, 30));
    }
    // 少し待ってからゲームオーバー画面へ
    setTimeout(gameOver, 1000);
}

function gameOver() {
    currentState = STATE.GAMEOVER;
    
    let isNewRecord = false;
    if (score > highScore) {
        highScore = score;
        isNewRecord = true;
        try {
            localStorage.setItem('ZeroDistance_HighScore', highScore);
        } catch(e) {
            console.log("Failed to save high score");
        }
    }

    let newRecordHtml = isNewRecord ? '<p class="blink" style="color:#ffff00; margin-bottom:10px;">NEW RECORD!</p>' : '';
    let scoreHtml = `<p>SCORE: ${score.toLocaleString()}</p>`;
    let highScoreHtml = `<p style="font-size:12px; color:#aaa; margin-top:5px;">HI-SCORE: ${highScore.toLocaleString()}</p>`;

    screenContent.innerHTML = `
        <p style="color:red; font-size: 24px; margin-bottom:20px;">GAME OVER</p>
        ${newRecordHtml}
        ${scoreHtml}
        ${highScoreHtml}
        <div class="blink" style="margin-top:30px;">[ TRY AGAIN ]</div>
    `;
    overlayScreen.classList.remove('hidden');
    bossHud.style.display = 'none';
    warningOverlay.style.display = 'none';
    shakeIntensity = 20;
    AudioSys.playExplosion();
}

function loop() {
    if (currentState === STATE.PLAYING || currentState === STATE.BOSS_WARNING) {
        requestAnimationFrame(loop);
        if (currentState === STATE.PLAYING) {
            update();
            draw();
        } else if (currentState === STATE.BOSS_WARNING) {
            draw(); // 背景でゲーム画面は出し続ける
        }
    }
}
</script>
</body>
</html>
